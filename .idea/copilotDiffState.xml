<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/infrastructure/processors/rife/native.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/infrastructure/processors/rife/native.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;Native Python implementation of RIFE interpolation processing.&#10;&#10;Replaces run_rife_pytorch.sh with pure Python code.&#10;Provides same functionality but with full Python debugging support.&#10;&#10;Usage:&#10;    from infrastructure.processors.rife.native import RIFENative&#10;&#10;    processor = RIFENative(factor=2)&#10;    output_frames = processor.process_frames(input_frames, output_dir)&#10;&quot;&quot;&quot;&#10;&#10;import os&#10;import sys&#10;import time&#10;from pathlib import Path&#10;from typing import List, Optional, Tuple&#10;import logging&#10;&#10;# Try to import torch&#10;try:&#10;    import torch&#10;    TORCH_AVAILABLE = True&#10;except ImportError:&#10;    TORCH_AVAILABLE = False&#10;&#10;&#10;class RIFENative:&#10;    &quot;&quot;&quot;&#10;    Native Python implementation of RIFE interpolation.&#10;&#10;    Replaces run_rife_pytorch.sh with pure Python.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(&#10;        self,&#10;        factor: float = 2.0,&#10;        model_path: Optional[Path] = None,&#10;        scale: float = 1.0,&#10;        device: str = 'cuda',&#10;        logger: Optional[logging.Logger] = None&#10;    ):&#10;        &quot;&quot;&quot;&#10;        Initialize RIFE processor.&#10;&#10;        Args:&#10;            factor: Interpolation factor (2 = double frames)&#10;            model_path: Path to RIFE model directory&#10;            scale: Spatial scaling (default 1.0 = no scaling)&#10;            device: Device to use&#10;            logger: Logger instance&#10;        &quot;&quot;&quot;&#10;        self.factor = factor&#10;        self.scale = scale&#10;        self.device = device&#10;        self.logger = logger or logging.getLogger(__name__)&#10;&#10;        # Find model&#10;        if model_path is None:&#10;            model_path = self._find_model_path()&#10;        self.model_path = model_path&#10;&#10;        # Model will be loaded on first use&#10;        self._model = None&#10;&#10;    def _find_model_path(self) -&gt; Path:&#10;        &quot;&quot;&quot;&#10;        Find RIFE model weights directory.&#10;&#10;        Note: This is for model WEIGHTS (train_log/*.pkl), not the code.&#10;        The code is loaded from external/RIFE.&#10;        &quot;&quot;&quot;&#10;        possible_paths = [&#10;            Path('/opt/rife_models/train_log'),  # Docker container preinstalled models (PRIORITY!)&#10;            Path('/workspace/project/RIFEv4.26_0921'),  # Preinstalled weights&#10;            Path('/workspace/project/external/RIFE/train_log'),  # Cloned repo weights&#10;            Path('RIFEv4.26_0921'),  # Local dev&#10;            Path('external/RIFE/train_log'),  # Local dev&#10;        ]&#10;&#10;        for path in possible_paths:&#10;            if path.exists() and list(path.glob('*.pkl')):  # Check for .pkl files&#10;                self.logger.info(f&quot;Found RIFE model weights: {path}&quot;)&#10;                return path&#10;&#10;        raise FileNotFoundError(&#10;            f&quot;RIFE model weights not found. Searched: {[str(p) for p in possible_paths]}&quot;&#10;        )&#10;&#10;    def _setup_model_package(self, rife_repo_path: Path):&#10;        &quot;&quot;&quot;&#10;        Set up model package for RIFE imports.&#10;&#10;        RIFE_HDv3.py needs 'from model.warplayer import warp' to work.&#10;        We need to ensure the model/ directory is properly on the Python path.&#10;        &quot;&quot;&quot;&#10;        # Add the RIFE repo root to sys.path (so &quot;import model&quot; works)&#10;        rife_root = str(rife_repo_path.absolute())&#10;        if rife_root not in sys.path:&#10;            sys.path.insert(0, rife_root)&#10;            self.logger.info(f&quot;Added {rife_root} to sys.path&quot;)&#10;&#10;        # Check if RIFE_HDv3.py was copied to root (done by remote_runner.sh)&#10;        rife_hdv3_root = rife_repo_path / 'RIFE_HDv3.py'&#10;        if rife_hdv3_root.exists():&#10;            self.logger.info(f&quot;✓ Found RIFE_HDv3.py in root: {rife_hdv3_root}&quot;)&#10;            # Also copy warplayer.py if needed&#10;            warplayer_root = rife_repo_path / 'warplayer.py'&#10;            warplayer_model = rife_repo_path / 'model' / 'warplayer.py'&#10;            if not warplayer_root.exists() and warplayer_model.exists():&#10;                import shutil&#10;                shutil.copy(warplayer_model, warplayer_root)&#10;                self.logger.info(f&quot;Copied warplayer.py to root&quot;)&#10;&#10;        # Find model directory&#10;        model_dir = rife_repo_path / 'model'&#10;        if model_dir.exists():&#10;            self.logger.info(f&quot;Setting up model package from {model_dir}&quot;)&#10;&#10;            # Create __init__.py in model/ if it doesn't exist (for Python package)&#10;            init_file = model_dir / '__init__.py'&#10;            if not init_file.exists():&#10;                init_file.write_text(&quot;# RIFE model package\n&quot;)&#10;                self.logger.info(f&quot;Created {init_file}&quot;)&#10;&#10;            # Verify model package can be imported&#10;            try:&#10;                # Force reload if already imported&#10;                import importlib&#10;                if 'model' in sys.modules:&#10;                    importlib.reload(sys.modules['model'])&#10;                if 'model.warplayer' in sys.modules:&#10;                    importlib.reload(sys.modules['model.warplayer'])&#10;&#10;                # Now try importing&#10;                import model&#10;                import model.warplayer&#10;                self.logger.info(&quot;✓ model.warplayer loaded successfully&quot;)&#10;            except ImportError as e:&#10;                self.logger.warning(f&quot;Could not import model.warplayer from model/: {e}&quot;)&#10;                # Try to copy files to root as fallback&#10;                try:&#10;                    import shutil&#10;                    for f in ['warplayer.py', 'IFNet_HDv3.py']:&#10;                        src = model_dir / f&#10;                        dst = rife_repo_path / f&#10;                        if src.exists() and not dst.exists():&#10;                            shutil.copy(src, dst)&#10;                            self.logger.info(f&quot;Copied {f} to root as fallback&quot;)&#10;                except Exception as copy_err:&#10;                    self.logger.warning(f&quot;Fallback copy failed: {copy_err}&quot;)&#10;        else:&#10;            self.logger.warning(f&quot;model/ directory not found in {rife_repo_path}, will try root files&quot;)&#10;&#10;    def _load_model(self):&#10;        &quot;&quot;&quot;Load RIFE model (lazy loading).&quot;&quot;&quot;&#10;        if self._model is not None:&#10;            return&#10;&#10;        if not TORCH_AVAILABLE:&#10;            raise ImportError(&quot;PyTorch not found. Install: pip install torch&quot;)&#10;&#10;        self.logger.info(f&quot;Loading RIFE model (weights from: {self.model_path})&quot;)&#10;&#10;        # Find RIFE repository - prioritize preinstalled RIFE over cloned repo&#10;        rife_repo_paths = [&#10;            Path('/workspace/project/RIFEv4.26_0921'),  # Preinstalled RIFE (priority!)&#10;            Path('RIFEv4.26_0921'),  # Local dev preinstalled&#10;            Path('/workspace/project/external/RIFE'),  # Cloned repo&#10;            Path('external/RIFE'),  # Local dev cloned&#10;            Path(__file__).parent.parent.parent.parent.parent / 'external' / 'RIFE',  # From src/&#10;        ]&#10;&#10;        rife_repo_path = None&#10;        for path in rife_repo_paths:&#10;            # Check if this path has the actual RIFE code (not just empty model/__init__.py)&#10;            if path and path.exists():&#10;                # Check for train_log directory (contains actual RIFE implementation)&#10;                has_train_log = (path / 'train_log').exists()&#10;                # Or check for model/RIFE_HDv3.py or model/RIFE.py&#10;                has_model_code = (path / 'model' / 'RIFE_HDv3.py').exists() or \&#10;                                 (path / 'model' / 'RIFE.py').exists()&#10;&#10;                if has_train_log or has_model_code:&#10;                    rife_repo_path = path&#10;                    self.logger.info(f&quot;✓ Found RIFE repository with code: {path}&quot;)&#10;                    break&#10;&#10;        if not rife_repo_path:&#10;            raise ImportError(&#10;                f&quot;RIFE repository with model code not found. Searched: {[str(p) for p in rife_repo_paths if p]}&quot;&#10;            )&#10;&#10;        # Set up model package (needed for model.warplayer imports)&#10;        self._setup_model_package(rife_repo_path)&#10;&#10;        # Find RIFE_HDv3.py or model/RIFE.py&#10;        # Priority: root (copied by remote_runner.sh) -&gt; model/ -&gt; train_log/&#10;        model_class_paths = [&#10;            (rife_repo_path / 'RIFE_HDv3.py', 'RIFE_HDv3_root', 'Model'),  # Copied to root by remote_runner.sh (PRIORITY!)&#10;            (rife_repo_path / 'model' / 'RIFE_HDv3.py', 'RIFE_HDv3_model', 'Model'),  # v4.6 (model dir)&#10;            (rife_repo_path / 'train_log' / 'RIFE_HDv3.py', 'RIFE_HDv3_train', 'Model'),  # v4.6+ (train_log)&#10;            (rife_repo_path / 'model' / 'RIFE.py', 'RIFE_model', 'Model'),  # v4.x&#10;            (rife_repo_path / 'train_log' / 'RIFE_HD.py', 'RIFE_HD', 'Model'),  # Older version&#10;        ]&#10;&#10;        model_class = None&#10;        last_error = None&#10;&#10;        for model_file, module_name, class_name in model_class_paths:&#10;            if not model_file.exists():&#10;                continue&#10;&#10;            self.logger.info(f&quot;Trying model file: {model_file}&quot;)&#10;            try:&#10;                # Import the module&#10;                import importlib.util&#10;                spec = importlib.util.spec_from_file_location(module_name, model_file)&#10;                if spec is None or spec.loader is None:&#10;                    self.logger.warning(f&quot;Could not create spec for {model_file}&quot;)&#10;                    continue&#10;&#10;                module = importlib.util.module_from_spec(spec)&#10;                sys.modules[module_name] = module&#10;                spec.loader.exec_module(module)&#10;&#10;                # Get the Model class&#10;                if hasattr(module, class_name):&#10;                    model_class = getattr(module, class_name)&#10;                    self.logger.info(f&quot;✓ Successfully loaded {module_name}.{class_name} from {model_file}&quot;)&#10;                    break&#10;                else:&#10;                    self.logger.warning(f&quot;Module {module_name} does not have {class_name} class&quot;)&#10;&#10;            except Exception as e:&#10;                last_error = e&#10;                self.logger.warning(f&quot;Failed to load {model_file}: {e}&quot;)&#10;                import traceback&#10;                self.logger.debug(traceback.format_exc())&#10;                continue&#10;&#10;        if not model_class:&#10;            tried_files = [str(p[0]) for p in model_class_paths if p[0].exists()]&#10;            error_msg = f&quot;Could not load RIFE Model class. Tried: {tried_files}&quot;&#10;            if last_error:&#10;                error_msg += f&quot;\nLast error: {last_error}&quot;&#10;            raise ImportError(error_msg)&#10;&#10;        try:&#10;            # Create model instance&#10;            self._model = model_class()&#10;&#10;            # Load model weights&#10;            weights_path = self.model_path&#10;            if not (weights_path / 'flownet.pkl').exists():&#10;                # If model_path doesn't have pkl files directly, check parent&#10;                if (weights_path.parent / 'flownet.pkl').exists():&#10;                    weights_path = weights_path.parent&#10;&#10;            self.logger.info(f&quot;Loading model weights from {weights_path}&quot;)&#10;            self._model.load_model(str(weights_path), -1)&#10;            self._model.eval()&#10;            self._model.device()&#10;&#10;            self.logger.info(&quot;✓ RIFE model loaded successfully&quot;)&#10;&#10;        except Exception as e:&#10;            raise ImportError(&#10;                f&quot;Failed to load RIFE model. Weights from {self.model_path}: {e}&quot;&#10;            ) from e&#10;&#10;    def _calculate_mids_per_pair(self) -&gt; int:&#10;        &quot;&quot;&quot;Calculate how many intermediate frames per pair.&quot;&quot;&quot;&#10;        # factor 2 -&gt; 1 mid, factor 4 -&gt; 3 mids, etc.&#10;        return max(1, int(self.factor) - 1)&#10;&#10;    def _interpolate_pair(&#10;        self,&#10;        frame1: torch.Tensor,&#10;        frame2: torch.Tensor,&#10;        mids_count: int&#10;    ) -&gt; List[torch.Tensor]:&#10;        &quot;&quot;&quot;&#10;        Interpolate between two frames.&#10;&#10;        Args:&#10;            frame1: First frame (tensor)&#10;            frame2: Second frame (tensor)&#10;            mids_count: Number of intermediate frames&#10;&#10;        Returns:&#10;            List of intermediate frames&#10;        &quot;&quot;&quot;&#10;        mids = []&#10;&#10;        with torch.no_grad():&#10;            for i in range(mids_count):&#10;                # Calculate timestep&#10;                timestep = (i + 1) / (mids_count + 1)&#10;&#10;                # Interpolate&#10;                mid = self._model.inference(frame1, frame2, timestep)&#10;                mids.append(mid)&#10;&#10;        return mids&#10;&#10;    def _load_frame_as_tensor(self, frame_path: Path) -&gt; torch.Tensor:&#10;        &quot;&quot;&quot;Load image file as torch tensor.&quot;&quot;&quot;&#10;        try:&#10;            import cv2&#10;            import numpy as np&#10;        except ImportError as e:&#10;            raise ImportError(&quot;opencv-python not found. Install: pip install opencv-python&quot;) from e&#10;&#10;        img = cv2.imread(str(frame_path))&#10;        if img is None:&#10;            raise ValueError(f&quot;Failed to load image: {frame_path}&quot;)&#10;&#10;        # Convert BGR to RGB&#10;        img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)&#10;&#10;        # Convert to tensor [1, 3, H, W]&#10;        img = torch.from_numpy(img).permute(2, 0, 1).unsqueeze(0).float() / 255.0&#10;&#10;        # Move to device&#10;        img = img.to(self.device)&#10;&#10;        return img&#10;&#10;    def _save_tensor_as_frame(self, tensor: torch.Tensor, output_path: Path):&#10;        &quot;&quot;&quot;Save torch tensor as image file.&quot;&quot;&quot;&#10;        try:&#10;            import cv2&#10;            import numpy as np&#10;        except ImportError as e:&#10;            raise ImportError(&quot;opencv-python not found. Install: pip install opencv-python&quot;) from e&#10;&#10;        # Tensor is [1, 3, H, W], convert to [H, W, 3]&#10;        img = tensor.squeeze(0).permute(1, 2, 0).cpu().numpy()&#10;&#10;        # Scale to 0-255&#10;        img = (img * 255).clip(0, 255).astype(np.uint8)&#10;&#10;        # Convert RGB to BGR&#10;        img = cv2.cvtColor(img, cv2.COLOR_RGB2BGR)&#10;&#10;        # Save&#10;        cv2.imwrite(str(output_path), img)&#10;&#10;    def process_frames(&#10;        self,&#10;        input_frames: List[Path],&#10;        output_dir: Path,&#10;        progress_callback: Optional[callable] = None&#10;    ) -&gt; List[Path]:&#10;        &quot;&quot;&quot;&#10;        Interpolate frames using RIFE.&#10;&#10;        Args:&#10;            input_frames: List of input frame paths&#10;            output_dir: Output directory&#10;            progress_callback: Optional callback(current, total)&#10;&#10;        Returns:&#10;            List of output frame paths (interleaved: orig1, mid, orig2, mid, ...)&#10;        &quot;&quot;&quot;&#10;        output_dir.mkdir(parents=True, exist_ok=True)&#10;&#10;        # Load model&#10;        self._load_model()&#10;&#10;        total_pairs = len(input_frames) - 1&#10;        mids_per_pair = self._calculate_mids_per_pair()&#10;&#10;        self.logger.info(f&quot;Interpolating {len(input_frames)} frames&quot;)&#10;        self.logger.info(f&quot;  Factor: {self.factor}x&quot;)&#10;        self.logger.info(f&quot;  Pairs to process: {total_pairs}&quot;)&#10;        self.logger.info(f&quot;  Mids per pair: {mids_per_pair}&quot;)&#10;&#10;        output_frames = []&#10;        start_time = time.time()&#10;&#10;        # Process pairs&#10;        for idx in range(total_pairs):&#10;            frame1_path = input_frames[idx]&#10;            frame2_path = input_frames[idx + 1]&#10;&#10;            try:&#10;                # Load frames as tensors&#10;                frame1 = self._load_frame_as_tensor(frame1_path)&#10;                frame2 = self._load_frame_as_tensor(frame2_path)&#10;&#10;                # Add original frame1 to output&#10;                output_frames.append(frame1_path)&#10;&#10;                # Generate intermediate frames&#10;                mids = self._interpolate_pair(frame1, frame2, mids_per_pair)&#10;&#10;                # Save intermediate frames&#10;                for mid_idx, mid in enumerate(mids, 1):&#10;                    mid_name = f&quot;{frame1_path.stem}_mid_{mid_idx:02d}.png&quot;&#10;                    mid_path = output_dir / mid_name&#10;                    self._save_tensor_as_frame(mid, mid_path)&#10;                    output_frames.append(mid_path)&#10;&#10;                # Progress&#10;                if (idx + 1) % 10 == 0 or (idx + 1) == total_pairs:&#10;                    elapsed = time.time() - start_time&#10;                    fps = (idx + 1) / elapsed if elapsed &gt; 0 else 0&#10;                    eta = (total_pairs - idx - 1) / fps if fps &gt; 0 else 0&#10;&#10;                    self.logger.info(&#10;                        f&quot;Processed {idx+1}/{total_pairs} pairs &quot;&#10;                        f&quot;({100*(idx+1)/total_pairs:.1f}%) | &quot;&#10;                        f&quot;{fps:.2f} fps | &quot;&#10;                        f&quot;ETA: {eta:.0f}s&quot;&#10;                    )&#10;&#10;                    if progress_callback:&#10;                        progress_callback(idx + 1, total_pairs)&#10;&#10;            except Exception as e:&#10;                self.logger.error(f&quot;Failed to process pair {idx+1}/{total_pairs}: {e}&quot;)&#10;                raise&#10;&#10;        # Add last frame&#10;        output_frames.append(input_frames[-1])&#10;&#10;        elapsed = time.time() - start_time&#10;        avg_fps = total_pairs / elapsed if elapsed &gt; 0 else 0&#10;&#10;        self.logger.info(&#10;            f&quot;✅ Completed {total_pairs} pairs in {elapsed:.1f}s &quot;&#10;            f&quot;({avg_fps:.2f} fps)&quot;&#10;        )&#10;        self.logger.info(f&quot;Generated {len(output_frames)} total frames&quot;)&#10;&#10;        return output_frames&#10;&#10;    def process_video(&#10;        self,&#10;        input_video: Path,&#10;        output_video: Path,&#10;        fps: Optional[float] = None&#10;    ) -&gt; Path:&#10;        &quot;&quot;&quot;&#10;        Interpolate entire video file.&#10;&#10;        Args:&#10;            input_video: Input video path&#10;            output_video: Output video path&#10;            fps: Output frame rate (auto-calculate if None)&#10;&#10;        Returns:&#10;            Output video path&#10;        &quot;&quot;&quot;&#10;        from infrastructure.media import FFmpegExtractor, FFmpegAssembler&#10;&#10;        # Create temporary directories&#10;        import tempfile&#10;&#10;        with tempfile.TemporaryDirectory() as temp_dir:&#10;            temp_path = Path(temp_dir)&#10;            frames_dir = temp_path / &quot;frames&quot;&#10;            output_frames_dir = temp_path / &quot;output&quot;&#10;            frames_dir.mkdir()&#10;            output_frames_dir.mkdir()&#10;&#10;            # Extract frames&#10;            self.logger.info(f&quot;Extracting frames from {input_video}&quot;)&#10;            extractor = FFmpegExtractor()&#10;            frames = extractor.extract_frames(input_video, frames_dir)&#10;&#10;            # Get video info&#10;            info = extractor.get_video_info(input_video)&#10;            if fps is None:&#10;                fps = info.fps * self.factor&#10;&#10;            # Interpolate&#10;            output_frames = self.process_frames(frames, output_frames_dir)&#10;&#10;            # Assemble video&#10;            self.logger.info(f&quot;Assembling video to {output_video}&quot;)&#10;            assembler = FFmpegAssembler()&#10;            result = assembler.assemble_video(&#10;                output_frames,&#10;                output_video,&#10;                fps=fps,&#10;                resolution=(info.width, info.height)&#10;            )&#10;&#10;            return output_video&#10;&#10;&#10;# CLI interface (for backward compatibility)&#10;def main():&#10;    &quot;&quot;&quot;CLI entry point - mimics shell script interface.&quot;&quot;&quot;&#10;    import argparse&#10;&#10;    parser = argparse.ArgumentParser(&#10;        description='RIFE Interpolation (Native Python Implementation)'&#10;    )&#10;    parser.add_argument('input', help='Input file (video or directory of frames)')&#10;    parser.add_argument('output', help='Output file or directory')&#10;    parser.add_argument('factor', type=float, nargs='?', default=2.0,&#10;                       help='Interpolation factor (default: 2.0)')&#10;    parser.add_argument('--model-path', type=Path, help='Path to RIFE model')&#10;&#10;    args = parser.parse_args()&#10;&#10;    # Setup logging&#10;    logging.basicConfig(&#10;        level=logging.INFO,&#10;        format='[%(asctime)s] %(message)s',&#10;        datefmt='%H:%M:%S'&#10;    )&#10;&#10;    input_path = Path(args.input)&#10;    output_path = Path(args.output)&#10;&#10;    # Create processor&#10;    processor = RIFENative(&#10;        factor=args.factor,&#10;        model_path=args.model_path&#10;    )&#10;&#10;    # Process&#10;    if input_path.is_file():&#10;        # Video file&#10;        processor.process_video(input_path, output_path)&#10;    elif input_path.is_dir():&#10;        # Directory of frames&#10;        frames = sorted(input_path.glob('*.png')) or sorted(input_path.glob('*.jpg'))&#10;        output_path.mkdir(parents=True, exist_ok=True)&#10;        processor.process_frames(frames, output_path)&#10;    else:&#10;        print(f&quot;Error: Input not found: {input_path}&quot;)&#10;        sys.exit(1)&#10;&#10;    print(f&quot;✅ Success: {output_path}&quot;)&#10;&#10;&#10;if __name__ == '__main__':&#10;    main()&#10;&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Native Python implementation of RIFE interpolation processing.&#10;&#10;Replaces run_rife_pytorch.sh with pure Python code.&#10;Provides same functionality but with full Python debugging support.&#10;&#10;Usage:&#10;    from infrastructure.processors.rife.native import RIFENative&#10;&#10;    processor = RIFENative(factor=2)&#10;    output_frames = processor.process_frames(input_frames, output_dir)&#10;&quot;&quot;&quot;&#10;&#10;import os&#10;import sys&#10;import time&#10;from pathlib import Path&#10;from typing import List, Optional, Tuple&#10;import logging&#10;&#10;# Try to import torch&#10;try:&#10;    import torch&#10;    TORCH_AVAILABLE = True&#10;except ImportError:&#10;    TORCH_AVAILABLE = False&#10;&#10;&#10;class RIFENative:&#10;    &quot;&quot;&quot;&#10;    Native Python implementation of RIFE interpolation.&#10;&#10;    Replaces run_rife_pytorch.sh with pure Python.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(&#10;        self,&#10;        factor: float = 2.0,&#10;        model_path: Optional[Path] = None,&#10;        scale: float = 1.0,&#10;        device: str = 'cuda',&#10;        logger: Optional[logging.Logger] = None&#10;    ):&#10;        &quot;&quot;&quot;&#10;        Initialize RIFE processor.&#10;&#10;        Args:&#10;            factor: Interpolation factor (2 = double frames)&#10;            model_path: Path to RIFE model directory&#10;            scale: Spatial scaling (default 1.0 = no scaling)&#10;            device: Device to use&#10;            logger: Logger instance&#10;        &quot;&quot;&quot;&#10;        self.factor = factor&#10;        self.scale = scale&#10;        self.device = device&#10;        self.logger = logger or logging.getLogger(__name__)&#10;&#10;        # Find model&#10;        if model_path is None:&#10;            model_path = self._find_model_path()&#10;        self.model_path = model_path&#10;&#10;        # Model will be loaded on first use&#10;        self._model = None&#10;&#10;    def _find_model_path(self) -&gt; Path:&#10;        &quot;&quot;&quot;&#10;        Find RIFE model weights directory.&#10;&#10;        Note: This is for model WEIGHTS (train_log/*.pkl), not the code.&#10;        The code is loaded from external/RIFE.&#10;        &quot;&quot;&quot;&#10;        possible_paths = [&#10;            Path('/opt/rife_models/train_log'),  # Docker container preinstalled models (PRIORITY!)&#10;            Path('/workspace/project/RIFEv4.26_0921'),  # Preinstalled weights&#10;            Path('/workspace/project/external/RIFE/train_log'),  # Cloned repo weights&#10;            Path('RIFEv4.26_0921'),  # Local dev&#10;            Path('external/RIFE/train_log'),  # Local dev&#10;        ]&#10;&#10;        for path in possible_paths:&#10;            if path.exists() and list(path.glob('*.pkl')):  # Check for .pkl files&#10;                self.logger.info(f&quot;Found RIFE model weights: {path}&quot;)&#10;                return path&#10;&#10;        raise FileNotFoundError(&#10;            f&quot;RIFE model weights not found. Searched: {[str(p) for p in possible_paths]}&quot;&#10;        )&#10;&#10;    def _setup_model_package(self, rife_repo_path: Path):&#10;        &quot;&quot;&quot;&#10;        Set up model package for RIFE imports.&#10;&#10;        RIFE_HDv3.py needs 'from model.warplayer import warp' to work.&#10;        We need to ensure the model/ directory is properly on the Python path.&#10;        &quot;&quot;&quot;&#10;        # Add the RIFE repo root to sys.path (so &quot;import model&quot; works)&#10;        rife_root = str(rife_repo_path.absolute())&#10;        if rife_root not in sys.path:&#10;            sys.path.insert(0, rife_root)&#10;            self.logger.info(f&quot;Added {rife_root} to sys.path&quot;)&#10;&#10;        # Check if RIFE_HDv3.py was copied to root (done by remote_runner.sh)&#10;        rife_hdv3_root = rife_repo_path / 'RIFE_HDv3.py'&#10;        if rife_hdv3_root.exists():&#10;            self.logger.info(f&quot;✓ Found RIFE_HDv3.py in root: {rife_hdv3_root}&quot;)&#10;            # Also copy warplayer.py if needed&#10;            warplayer_root = rife_repo_path / 'warplayer.py'&#10;            warplayer_model = rife_repo_path / 'model' / 'warplayer.py'&#10;            if not warplayer_root.exists() and warplayer_model.exists():&#10;                import shutil&#10;                shutil.copy(warplayer_model, warplayer_root)&#10;                self.logger.info(f&quot;Copied warplayer.py to root&quot;)&#10;&#10;        # Find model directory&#10;        model_dir = rife_repo_path / 'model'&#10;        if model_dir.exists():&#10;            self.logger.info(f&quot;Setting up model package from {model_dir}&quot;)&#10;&#10;            # Create __init__.py in model/ if it doesn't exist (for Python package)&#10;            init_file = model_dir / '__init__.py'&#10;            if not init_file.exists():&#10;                init_file.write_text(&quot;# RIFE model package\n&quot;)&#10;                self.logger.info(f&quot;Created {init_file}&quot;)&#10;&#10;            # Verify model package can be imported&#10;            try:&#10;                # Force reload if already imported&#10;                import importlib&#10;                if 'model' in sys.modules:&#10;                    importlib.reload(sys.modules['model'])&#10;                if 'model.warplayer' in sys.modules:&#10;                    importlib.reload(sys.modules['model.warplayer'])&#10;&#10;                # Now try importing&#10;                import model&#10;                import model.warplayer&#10;                self.logger.info(&quot;✓ model.warplayer loaded successfully&quot;)&#10;            except ImportError as e:&#10;                self.logger.warning(f&quot;Could not import model.warplayer from model/: {e}&quot;)&#10;                # Try to copy files to root as fallback&#10;                try:&#10;                    import shutil&#10;                    for f in ['warplayer.py', 'IFNet_HDv3.py']:&#10;                        src = model_dir / f&#10;                        dst = rife_repo_path / f&#10;                        if src.exists() and not dst.exists():&#10;                            shutil.copy(src, dst)&#10;                            self.logger.info(f&quot;Copied {f} to root as fallback&quot;)&#10;                except Exception as copy_err:&#10;                    self.logger.warning(f&quot;Fallback copy failed: {copy_err}&quot;)&#10;        else:&#10;            self.logger.warning(f&quot;model/ directory not found in {rife_repo_path}, will try root files&quot;)&#10;&#10;    def _load_model(self):&#10;        &quot;&quot;&quot;Load RIFE model (lazy loading).&quot;&quot;&quot;&#10;        if self._model is not None:&#10;            return&#10;&#10;        if not TORCH_AVAILABLE:&#10;            raise ImportError(&quot;PyTorch not found. Install: pip install torch&quot;)&#10;&#10;        self.logger.info(f&quot;Loading RIFE model (weights from: {self.model_path})&quot;)&#10;&#10;        # Find RIFE repository - prioritize preinstalled RIFE over cloned repo&#10;        rife_repo_paths = [&#10;            Path('/workspace/project/RIFEv4.26_0921'),  # Preinstalled RIFE (priority!)&#10;            Path('RIFEv4.26_0921'),  # Local dev preinstalled&#10;            Path('/workspace/project/external/RIFE'),  # Cloned repo&#10;            Path('external/RIFE'),  # Local dev cloned&#10;            Path(__file__).parent.parent.parent.parent.parent / 'external' / 'RIFE',  # From src/&#10;        ]&#10;&#10;        rife_repo_path = None&#10;        for path in rife_repo_paths:&#10;            # Check if this path has the actual RIFE code (not just empty model/__init__.py)&#10;            if path and path.exists():&#10;                # Check for train_log directory (contains actual RIFE implementation)&#10;                has_train_log = (path / 'train_log').exists()&#10;                # Or check for model/RIFE_HDv3.py or model/RIFE.py&#10;                has_model_code = (path / 'model' / 'RIFE_HDv3.py').exists() or \&#10;                                 (path / 'model' / 'RIFE.py').exists()&#10;&#10;                if has_train_log or has_model_code:&#10;                    rife_repo_path = path&#10;                    self.logger.info(f&quot;✓ Found RIFE repository with code: {path}&quot;)&#10;                    break&#10;&#10;        if not rife_repo_path:&#10;            raise ImportError(&#10;                f&quot;RIFE repository with model code not found. Searched: {[str(p) for p in rife_repo_paths if p]}&quot;&#10;            )&#10;&#10;        # Set up model package (needed for model.warplayer imports)&#10;        self._setup_model_package(rife_repo_path)&#10;&#10;        # Find RIFE_HDv3.py or model/RIFE.py&#10;        # Priority: root (copied by remote_runner.sh) -&gt; model/ -&gt; train_log/&#10;        model_class_paths = [&#10;            (rife_repo_path / 'RIFE_HDv3.py', 'RIFE_HDv3_root', 'Model'),  # Copied to root by remote_runner.sh (PRIORITY!)&#10;            (rife_repo_path / 'model' / 'RIFE_HDv3.py', 'RIFE_HDv3_model', 'Model'),  # v4.6 (model dir)&#10;            (rife_repo_path / 'train_log' / 'RIFE_HDv3.py', 'RIFE_HDv3_train', 'Model'),  # v4.6+ (train_log)&#10;            (rife_repo_path / 'model' / 'RIFE.py', 'RIFE_model', 'Model'),  # v4.x&#10;            (rife_repo_path / 'train_log' / 'RIFE_HD.py', 'RIFE_HD', 'Model'),  # Older version&#10;        ]&#10;&#10;        model_class = None&#10;        last_error = None&#10;&#10;        for model_file, module_name, class_name in model_class_paths:&#10;            if not model_file.exists():&#10;                continue&#10;&#10;            self.logger.info(f&quot;Trying model file: {model_file}&quot;)&#10;            try:&#10;                # Import the module&#10;                import importlib.util&#10;                spec = importlib.util.spec_from_file_location(module_name, model_file)&#10;                if spec is None or spec.loader is None:&#10;                    self.logger.warning(f&quot;Could not create spec for {model_file}&quot;)&#10;                    continue&#10;&#10;                module = importlib.util.module_from_spec(spec)&#10;                sys.modules[module_name] = module&#10;                spec.loader.exec_module(module)&#10;&#10;                # Get the Model class&#10;                if hasattr(module, class_name):&#10;                    model_class = getattr(module, class_name)&#10;                    self.logger.info(f&quot;✓ Successfully loaded {module_name}.{class_name} from {model_file}&quot;)&#10;                    break&#10;                else:&#10;                    self.logger.warning(f&quot;Module {module_name} does not have {class_name} class&quot;)&#10;&#10;            except Exception as e:&#10;                last_error = e&#10;                self.logger.warning(f&quot;Failed to load {model_file}: {e}&quot;)&#10;                import traceback&#10;                self.logger.debug(traceback.format_exc())&#10;                continue&#10;&#10;        if not model_class:&#10;            tried_files = [str(p[0]) for p in model_class_paths if p[0].exists()]&#10;            error_msg = f&quot;Could not load RIFE Model class. Tried: {tried_files}&quot;&#10;            if last_error:&#10;                error_msg += f&quot;\nLast error: {last_error}&quot;&#10;            raise ImportError(error_msg)&#10;&#10;        try:&#10;            # Create model instance&#10;            self._model = model_class()&#10;&#10;            # Load model weights&#10;            weights_path = self.model_path&#10;            if not (weights_path / 'flownet.pkl').exists():&#10;                # If model_path doesn't have pkl files directly, check parent&#10;                if (weights_path.parent / 'flownet.pkl').exists():&#10;                    weights_path = weights_path.parent&#10;&#10;            self.logger.info(f&quot;Loading model weights from {weights_path}&quot;)&#10;            self._model.load_model(str(weights_path), -1)&#10;            self._model.eval()&#10;            self._model.device()&#10;&#10;            self.logger.info(&quot;✓ RIFE model loaded successfully&quot;)&#10;&#10;        except Exception as e:&#10;            raise ImportError(&#10;                f&quot;Failed to load RIFE model. Weights from {self.model_path}: {e}&quot;&#10;            ) from e&#10;&#10;    def _calculate_mids_per_pair(self) -&gt; int:&#10;        &quot;&quot;&quot;Calculate how many intermediate frames per pair.&quot;&quot;&quot;&#10;        # factor 2 -&gt; 1 mid, factor 4 -&gt; 3 mids, etc.&#10;        return max(1, int(self.factor) - 1)&#10;&#10;    def _pad_to_multiple(self, tensor: torch.Tensor, multiple: int = 64) -&gt; tuple:&#10;        &quot;&quot;&quot;&#10;        Pad tensor to multiple of given size.&#10;        &#10;        Args:&#10;            tensor: Input tensor [1, C, H, W]&#10;            multiple: Pad to multiple of this value (default 64)&#10;            &#10;        Returns:&#10;            Tuple of (padded_tensor, original_height, original_width)&#10;        &quot;&quot;&quot;&#10;        n, c, h, w = tensor.shape&#10;        ph = ((h - 1) // multiple + 1) * multiple&#10;        pw = ((w - 1) // multiple + 1) * multiple&#10;        &#10;        # Calculate padding (left, right, top, bottom)&#10;        pad = (0, pw - w, 0, ph - h)&#10;        &#10;        if pad[1] != 0 or pad[3] != 0:&#10;            import torch.nn.functional as F&#10;            tensor = F.pad(tensor, pad)&#10;            &#10;        return tensor, h, w&#10;&#10;    def _interpolate_pair(&#10;        self,&#10;        frame1: torch.Tensor,&#10;        frame2: torch.Tensor,&#10;        mids_count: int&#10;    ) -&gt; List[torch.Tensor]:&#10;        &quot;&quot;&quot;&#10;        Interpolate between two frames.&#10;&#10;        Args:&#10;            frame1: First frame (tensor)&#10;            frame2: Second frame (tensor)&#10;            mids_count: Number of intermediate frames&#10;&#10;        Returns:&#10;            List of intermediate frames&#10;        &quot;&quot;&quot;&#10;        # Store original dimensions&#10;        _, _, orig_h, orig_w = frame1.shape&#10;        &#10;        # Pad to multiples of 64 (RIFE model requirement)&#10;        frame1_padded, _, _ = self._pad_to_multiple(frame1, 64)&#10;        frame2_padded, _, _ = self._pad_to_multiple(frame2, 64)&#10;        &#10;        mids = []&#10;&#10;        with torch.no_grad():&#10;            for i in range(mids_count):&#10;                # Calculate timestep&#10;                timestep = (i + 1) / (mids_count + 1)&#10;&#10;                # Interpolate&#10;                mid = self._model.inference(frame1_padded, frame2_padded, timestep)&#10;                &#10;                # Crop back to original dimensions&#10;                mid = mid[:, :, :orig_h, :orig_w]&#10;                &#10;                mids.append(mid)&#10;&#10;        return mids&#10;&#10;    def _load_frame_as_tensor(self, frame_path: Path) -&gt; torch.Tensor:&#10;        &quot;&quot;&quot;Load image file as torch tensor.&quot;&quot;&quot;&#10;        try:&#10;            import cv2&#10;            import numpy as np&#10;        except ImportError as e:&#10;            raise ImportError(&quot;opencv-python not found. Install: pip install opencv-python&quot;) from e&#10;&#10;        img = cv2.imread(str(frame_path))&#10;        if img is None:&#10;            raise ValueError(f&quot;Failed to load image: {frame_path}&quot;)&#10;&#10;        # Convert BGR to RGB&#10;        img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)&#10;&#10;        # Convert to tensor [1, 3, H, W]&#10;        img = torch.from_numpy(img).permute(2, 0, 1).unsqueeze(0).float() / 255.0&#10;&#10;        # Move to device&#10;        img = img.to(self.device)&#10;&#10;        return img&#10;&#10;    def _save_tensor_as_frame(self, tensor: torch.Tensor, output_path: Path):&#10;        &quot;&quot;&quot;Save torch tensor as image file.&quot;&quot;&quot;&#10;        try:&#10;            import cv2&#10;            import numpy as np&#10;        except ImportError as e:&#10;            raise ImportError(&quot;opencv-python not found. Install: pip install opencv-python&quot;) from e&#10;&#10;        # Tensor is [1, 3, H, W], convert to [H, W, 3]&#10;        img = tensor.squeeze(0).permute(1, 2, 0).cpu().numpy()&#10;&#10;        # Scale to 0-255&#10;        img = (img * 255).clip(0, 255).astype(np.uint8)&#10;&#10;        # Convert RGB to BGR&#10;        img = cv2.cvtColor(img, cv2.COLOR_RGB2BGR)&#10;&#10;        # Save&#10;        cv2.imwrite(str(output_path), img)&#10;&#10;    def process_frames(&#10;        self,&#10;        input_frames: List[Path],&#10;        output_dir: Path,&#10;        progress_callback: Optional[callable] = None&#10;    ) -&gt; List[Path]:&#10;        &quot;&quot;&quot;&#10;        Interpolate frames using RIFE.&#10;&#10;        Args:&#10;            input_frames: List of input frame paths&#10;            output_dir: Output directory&#10;            progress_callback: Optional callback(current, total)&#10;&#10;        Returns:&#10;            List of output frame paths (interleaved: orig1, mid, orig2, mid, ...)&#10;        &quot;&quot;&quot;&#10;        output_dir.mkdir(parents=True, exist_ok=True)&#10;&#10;        # Load model&#10;        self._load_model()&#10;&#10;        total_pairs = len(input_frames) - 1&#10;        mids_per_pair = self._calculate_mids_per_pair()&#10;&#10;        self.logger.info(f&quot;Interpolating {len(input_frames)} frames&quot;)&#10;        self.logger.info(f&quot;  Factor: {self.factor}x&quot;)&#10;        self.logger.info(f&quot;  Pairs to process: {total_pairs}&quot;)&#10;        self.logger.info(f&quot;  Mids per pair: {mids_per_pair}&quot;)&#10;&#10;        output_frames = []&#10;        start_time = time.time()&#10;&#10;        # Process pairs&#10;        for idx in range(total_pairs):&#10;            frame1_path = input_frames[idx]&#10;            frame2_path = input_frames[idx + 1]&#10;&#10;            try:&#10;                # Load frames as tensors&#10;                frame1 = self._load_frame_as_tensor(frame1_path)&#10;                frame2 = self._load_frame_as_tensor(frame2_path)&#10;&#10;                # Add original frame1 to output&#10;                output_frames.append(frame1_path)&#10;&#10;                # Generate intermediate frames&#10;                mids = self._interpolate_pair(frame1, frame2, mids_per_pair)&#10;&#10;                # Save intermediate frames&#10;                for mid_idx, mid in enumerate(mids, 1):&#10;                    mid_name = f&quot;{frame1_path.stem}_mid_{mid_idx:02d}.png&quot;&#10;                    mid_path = output_dir / mid_name&#10;                    self._save_tensor_as_frame(mid, mid_path)&#10;                    output_frames.append(mid_path)&#10;&#10;                # Progress&#10;                if (idx + 1) % 10 == 0 or (idx + 1) == total_pairs:&#10;                    elapsed = time.time() - start_time&#10;                    fps = (idx + 1) / elapsed if elapsed &gt; 0 else 0&#10;                    eta = (total_pairs - idx - 1) / fps if fps &gt; 0 else 0&#10;&#10;                    self.logger.info(&#10;                        f&quot;Processed {idx+1}/{total_pairs} pairs &quot;&#10;                        f&quot;({100*(idx+1)/total_pairs:.1f}%) | &quot;&#10;                        f&quot;{fps:.2f} fps | &quot;&#10;                        f&quot;ETA: {eta:.0f}s&quot;&#10;                    )&#10;&#10;                    if progress_callback:&#10;                        progress_callback(idx + 1, total_pairs)&#10;&#10;            except Exception as e:&#10;                self.logger.error(f&quot;Failed to process pair {idx+1}/{total_pairs}: {e}&quot;)&#10;                raise&#10;&#10;        # Add last frame&#10;        output_frames.append(input_frames[-1])&#10;&#10;        elapsed = time.time() - start_time&#10;        avg_fps = total_pairs / elapsed if elapsed &gt; 0 else 0&#10;&#10;        self.logger.info(&#10;            f&quot;✅ Completed {total_pairs} pairs in {elapsed:.1f}s &quot;&#10;            f&quot;({avg_fps:.2f} fps)&quot;&#10;        )&#10;        self.logger.info(f&quot;Generated {len(output_frames)} total frames&quot;)&#10;&#10;        return output_frames&#10;&#10;    def process_video(&#10;        self,&#10;        input_video: Path,&#10;        output_video: Path,&#10;        fps: Optional[float] = None&#10;    ) -&gt; Path:&#10;        &quot;&quot;&quot;&#10;        Interpolate entire video file.&#10;&#10;        Args:&#10;            input_video: Input video path&#10;            output_video: Output video path&#10;            fps: Output frame rate (auto-calculate if None)&#10;&#10;        Returns:&#10;            Output video path&#10;        &quot;&quot;&quot;&#10;        from infrastructure.media import FFmpegExtractor, FFmpegAssembler&#10;&#10;        # Create temporary directories&#10;        import tempfile&#10;&#10;        with tempfile.TemporaryDirectory() as temp_dir:&#10;            temp_path = Path(temp_dir)&#10;            frames_dir = temp_path / &quot;frames&quot;&#10;            output_frames_dir = temp_path / &quot;output&quot;&#10;            frames_dir.mkdir()&#10;            output_frames_dir.mkdir()&#10;&#10;            # Extract frames&#10;            self.logger.info(f&quot;Extracting frames from {input_video}&quot;)&#10;            extractor = FFmpegExtractor()&#10;            frames = extractor.extract_frames(input_video, frames_dir)&#10;&#10;            # Get video info&#10;            info = extractor.get_video_info(input_video)&#10;            if fps is None:&#10;                fps = info.fps * self.factor&#10;&#10;            # Interpolate&#10;            output_frames = self.process_frames(frames, output_frames_dir)&#10;&#10;            # Assemble video&#10;            self.logger.info(f&quot;Assembling video to {output_video}&quot;)&#10;            assembler = FFmpegAssembler()&#10;            result = assembler.assemble_video(&#10;                output_frames,&#10;                output_video,&#10;                fps=fps,&#10;                resolution=(info.width, info.height)&#10;            )&#10;&#10;            return output_video&#10;&#10;&#10;# CLI interface (for backward compatibility)&#10;def main():&#10;    &quot;&quot;&quot;CLI entry point - mimics shell script interface.&quot;&quot;&quot;&#10;    import argparse&#10;&#10;    parser = argparse.ArgumentParser(&#10;        description='RIFE Interpolation (Native Python Implementation)'&#10;    )&#10;    parser.add_argument('input', help='Input file (video or directory of frames)')&#10;    parser.add_argument('output', help='Output file or directory')&#10;    parser.add_argument('factor', type=float, nargs='?', default=2.0,&#10;                       help='Interpolation factor (default: 2.0)')&#10;    parser.add_argument('--model-path', type=Path, help='Path to RIFE model')&#10;&#10;    args = parser.parse_args()&#10;&#10;    # Setup logging&#10;    logging.basicConfig(&#10;        level=logging.INFO,&#10;        format='[%(asctime)s] %(message)s',&#10;        datefmt='%H:%M:%S'&#10;    )&#10;&#10;    input_path = Path(args.input)&#10;    output_path = Path(args.output)&#10;&#10;    # Create processor&#10;    processor = RIFENative(&#10;        factor=args.factor,&#10;        model_path=args.model_path&#10;    )&#10;&#10;    # Process&#10;    if input_path.is_file():&#10;        # Video file&#10;        processor.process_video(input_path, output_path)&#10;    elif input_path.is_dir():&#10;        # Directory of frames&#10;        frames = sorted(input_path.glob('*.png')) or sorted(input_path.glob('*.jpg'))&#10;        output_path.mkdir(parents=True, exist_ok=True)&#10;        processor.process_frames(frames, output_path)&#10;    else:&#10;        print(f&quot;Error: Input not found: {input_path}&quot;)&#10;        sys.exit(1)&#10;&#10;    print(f&quot;✅ Success: {output_path}&quot;)&#10;&#10;&#10;if __name__ == '__main__':&#10;    main()&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>